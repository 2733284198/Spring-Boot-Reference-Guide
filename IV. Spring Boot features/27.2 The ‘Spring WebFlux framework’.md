### 27.2 Spring WebFlux框架

Spring WebFlux是Spring Framework 5.0中引入的新的响应式网络框架。不同与Spring MVC，它不需要Servlet API，是完全异步、非阻塞的，通过[Reactor项目](https://projectreactor.io/)实现了[Reactive Streams](http://www.reactive-streams.org/) 规范。 

Spring WebFlux有两种风格：函数式和基于注解。基于注解的风格相当接近于Spring MVC模型，如下所示：
```java
@RestController
@RequestMapping("/users")
public class MyRestController {

	@GetMapping("/{user}")
	public Mono<User> getUser(@PathVariable Long user) {
		// ...
	}
	
	@GetMapping("/{user}/customers")
	public Flux<Customer> getUserCustomers(@PathVariable Long user) {
		// ...
	}
	
	@DeleteMapping("/{user}")
	public Mono<User> deleteUser(@PathVariable Long user) {
		// ...
	}

}
```
“WebFlux.fn”——函数式变体，从请求的实际处理中分离了路由配置，如下所示：
```java
@Configuration
public class RoutingConfiguration {

	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(UserHandler userHandler) {
		return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
				.andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
				.andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
	}

}

@Component
public class UserHandler {

	public Mono<ServerResponse> getUser(ServerRequest request) {
		// ...
	}
	
	public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
		// ...
	}
	
	public Mono<ServerResponse> deleteUser(ServerRequest request) {
		// ...
	}
}
```
WebFlux是Spring框架的一部分。详细信息请查看它的[参考文档](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn)。

**注** You can define as many `RouterFunction` beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence.

To get started, add the `spring-boot-starter-webflux` module to your application.

**注** Adding both `spring-boot-starter-web` and `spring-boot-starter-webflux` modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux. This behavior has been chosen because many Spring developers add `spring-boot-starter-webflux` to their Spring MVC application to use the reactive `WebClient`. You can still enforce your choice by setting the chosen application type to `SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)`.